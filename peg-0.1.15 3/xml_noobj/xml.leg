# LE Grammar for LE Grammars
# 
# Copyright (c) 2007 by Ian Piumarta
# All rights reserved.
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the 'Software'),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, provided that the above copyright notice(s) and this
# permission notice appear in all copies of the Software.  Acknowledgement
# of the use of this Software in supporting documentation would be
# appreciated but is not required.
# 
# THE SOFTWARE IS PROVIDED 'AS IS'.  USE ENTIRELY AT YOUR OWN RISK.
# 
# Last edited: 2013-08-16 00:14:11 by piumarta on emilia

%{

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <libgen.h>
# include <assert.h>
# include <time.h>
#include <sys/time.h> // gettimeofday

  typedef struct Header Header;

  struct Header {
    char   *text;
    Header *next;
  };

  FILE *input= 0;

  int   verboseFlag= 0;

  static int	 lineNumber= 0;
  static char	*fileName= 0;
  static char	*trailer= 0;
  static Header	*headers= 0;

  void makeHeader(char *text);
  void makeTrailer(char *text);

  void yyerror(char *message);

# define YY_INPUT(buf, result, max)		\
  {						\
    int c= getc(input);				\
    if ('\n' == c || '\r' == c) ++lineNumber;	\
    result= (EOF == c) ? 0 : (*(buf)= c, 1);	\
  }

# define YY_LOCAL(T)	static T
# define YY_RULE(T)	static T
%}

File
  = PROLOG? S* DTD? S* Xml S*

PROLOG
  = '<?xml' (pro_str) '?>'

pro_str
  = (!'?>' .)*

DTD
  = '<!' (dtd_text) '>'

dtd_text
  = (!'>' .)*

Xml
  = '<' Name (S+ Attribute)* S* ( '/>' | '>' S* (Content)? '</' NAME '>' ) S*

Content
  = (Value | COMMENT) (Value | COMMENT)*

Name
  = [A-Za-z:] ('-' | [.0-9:A-Z_a-z])*

NAME
  = [A-Za-z:] ('-' | [.0-9:A-Z_a-z])* 

Attribute
  = Name S* '=' S* String

String
  = '"' str '"'

str = (!'"' .)*

Value
  = Xml
  | CDataSec
  | Text

CDataSec
  = '<![CDATA[' c:CDATA ']]>' S*

CDATA
  = (!']]>' !'<![CDATA[' .)*
    ('<![CDATA[' CDATA ']]>' CDATA)?

COMMENT
  = '<!--' (!'-->' .)* '-->' S*

Text
  = (!'<' .)+

S
  = [ \n\t\r]

%%

void yyerror(char *message)
{
  fprintf(stderr, "%s:%d: %s", fileName, lineNumber, message);
  if (yyctx->__text[0]) fprintf(stderr, " near token '%s'", yyctx->__text);
  if (yyctx->__pos < yyctx->__limit || !feof(input))
    {
      yyctx->__buf[yyctx->__limit]= '\0';
      fprintf(stderr, " before text \"");
      while (yyctx->__pos < yyctx->__limit)
	{
	  if ('\n' == yyctx->__buf[yyctx->__pos] || '\r' == yyctx->__buf[yyctx->__pos]) break;
	  fputc(yyctx->__buf[yyctx->__pos++], stderr);
	}
      if (yyctx->__pos == yyctx->__limit)
	{
	  int c;
	  while (EOF != (c= fgetc(input)) && '\n' != c && '\r' != c)
	    fputc(c, stderr);
	}
      fputc('\"', stderr);
    }
  fprintf(stderr, "\n");
  exit(1);
}

void makeHeader(char *text)
{
  Header *header= (Header *)malloc(sizeof(Header));
  header->text= strdup(text);
  header->next= headers;
  headers= header;
}

void makeTrailer(char *text)
{
  trailer= strdup(text);
}

static void usage(char *name)
{
  fprintf(stderr, "usage: %s [<option>...] [<file>...]\n", name);
  fprintf(stderr, "where <option> can be\n");
  fprintf(stderr, "  -h          print this help information\n");
  fprintf(stderr, "  -o <ofile>  write output to <ofile>\n");
  fprintf(stderr, "  -v          be verbose\n");
  fprintf(stderr, "  -V          print version number and exit\n");
  fprintf(stderr, "if no <file> is given, input is read from stdin\n");
  fprintf(stderr, "if no <ofile> is given, output is written to stdout\n");
  exit(1);
}

uint64_t timer() {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

int main(int argc, char **argv)
{
  input= stdin;
  lineNumber= 1;
  fileName= "<stdin>";
  
  for (int i = 0; i < 5; i++) {
    if (argc >= 2) {
      if (!(input = fopen(argv[1], "r"))) {
        fprintf(stderr, "File [%s] is not found!\n", argv[1]);
        return 1;
      }
    }
  
    uint64_t start, end;
    start = timer();
    if ((yyparse())) {
      //json_print(stdout, json);
    } else {
      printf("xml error!\n");
    }
    end = timer();
  
    printf("ElapsedTime: %llu msec\n", end - start);
  }

  return 0;
}
# LE Grammar for LE Grammars
# 
# Copyright (c) 2007 by Ian Piumarta
# All rights reserved.
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the 'Software'),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, provided that the above copyright notice(s) and this
# permission notice appear in all copies of the Software.  Acknowledgement
# of the use of this Software in supporting documentation would be
# appreciated but is not required.
# 
# THE SOFTWARE IS PROVIDED 'AS IS'.  USE ENTIRELY AT YOUR OWN RISK.
# 
# Last edited: 2013-08-16 00:14:11 by piumarta on emilia

%{

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <libgen.h>
# include <assert.h>
# include <time.h>
#include <sys/time.h> // gettimeofday

  typedef struct Header Header;

  struct Header {
    char   *text;
    Header *next;
  };

  FILE *input= 0;

  int   verboseFlag= 0;

  static int	 lineNumber= 0;
  static char	*fileName= 0;
  static char	*trailer= 0;
  static Header	*headers= 0;

  void makeHeader(char *text);
  void makeTrailer(char *text);

  void yyerror(char *message);

# define YY_INPUT(buf, result, max)		\
  {						\
    int c= getc(input);				\
    if ('\n' == c || '\r' == c) ++lineNumber;	\
    result= (EOF == c) ? 0 : (*(buf)= c, 1);	\
  }

# define YY_LOCAL(T)	static T
# define YY_RULE(T)	static T
%}

File
  = _ ( TopLevel | _ )* EOT

_
  = (S | BLOCKCOMMENT | LINECOMMENT | ATTRIBUTE)*

S
  = [ \n\r\t\u000B\u000C]

BLOCKCOMMENT
  = '/*' (!'*/' .)* '*/'

LINECOMMENT
  = '//' (!'\n' .)*

ATTRIBUTE
  = '__attribute__' !W _ '((' ATTRIBUTECONTENT '))' _
  | '__asm' !W _ '(' (!')' .)* ')' _

ATTRIBUTECONTENT
  = NAME _ '(' ('"' STRING_CONTENT* '"' | (!')' .)* ) _ ')'_
  | _ (!'))' .)* _


EOL
  = ('\r'? '\n' | !.)

DIGIT
  = [0-9]

W
  = [a-zA-Z0-9_]
  | UCHAR

UCHAR
  = '\\u' HEX4
  | '\\U' HEX4 HEX4

HEX4
  = HEX HEX HEX HEX

Name
  = NAME _ 

NAME
  = !DIGIT !(KEYWORD !W) W+

KEYWORD
  = 'auto' | 'break' | 'case' | 'char' | 'const' | 'continue' | 'default' 
  | 'double' | 'do' | 'else' | 'enum' | 'extern' | 'float' | 'for' 
  | 'goto' | 'if' | 'int' | 'inline' | 'long' | 'register' | 'restrict' 
  | 'return' | 'short' | 'signed' | 'sizeof' | 'static' | 'struct' 
  | 'switch' | 'typedef' | 'union' | 'unsigned' | 'void' | 'volatile' 
  | 'while' | '_Bool' | '_Complex' | '_Imaginary' | '_stdcall' 
  | '__declspec' | '__attribute__' | '__asm'

EOT = !.

TopLevel
  = Directive
  | TypeDef
  | Declaration
  | (';' _ | EOL) 

Declaration
  = FunctionDeclaration
  | StructDeclaration _ (';' _ | EOL) 
  | VariableDeclaration

Directive
  = '#' _ 'include' !W _ (!'\n' .)*
  | '#' _ 'define' !W _  (&'\\\n' .. | !'\n' .)*
  | '#' _ (&'\\\n' .. | !'\n' .)*


FunctionDeclaration
  = AnnotationList Type _ Name _ '(' _ FunctionParamList ')' _ (_ Block |_ (';' _ | EOL) )

AnnotationList
  = (Annotation)* _

Annotation
  = "extern"  !W _   _
  | "static"  !W _   _
  | "inline"   !W _  _
  | "__inline" !W _  _
  | "auto"     !W _  _
  | "register" !W _  _
  | "volatile"  !W _ _
  | "__declspec" !W _ '(' _ ')' _ _
  | "inline" !W _
  | "_stdcall" !W  _

FunctionParamList
  = ( FunctionParam (',' _ FunctionParam)* )? (',' _ '...' _)?
  | _ 'void' _

FunctionParam
  = Type _ (VarName)? _
  

TypeDef
  = 'typedef' !W _ _ Type (_ VarName _|_ Name _)? (',' _ VarName _|_ Name _)* (';' _ | EOL) 

VariableDeclaration
  = AnnotationList Type InitDecl (',' _ InitDecl)*  ATTRIBUTE? (';' _ | EOL)  
  | AnnotationList Type ('=' !'=' _ Initializer)? (',' _ InitDecl)* ATTRIBUTE? (';' _ | EOL)

InitDecl
  = VarName ('=' !'=' _ Initializer)? _

InitDeclAssign
  = VarName '=' !'=' _ Initializer _

VarName
  = '*' !'=' _ VarName _
  | Name ('[' _ (ConstantExpression)? ']' _ )*

Initializer
  = AssignmentExpression
  | '{' _ (addInitializerList)* ',' _? '}' _

addInitializerList
  = (Designation | Initializer)? (',' _ (Designation | Initializer))*

Designation
  = (Designator)+ '=' !'=' _ Initializer 
  
Designator
  = '[' _ ConstantExpression ']' _
  | '.' _ Name _


Type
  = "const" _ TypeSuffix _
  | TypeSuffix

TypeSuffix
  = PrimaryType (
    POINTER_QUALIFIER? '*' !'=' _ POINTER_QUALIFIER?
    | '[' _ (NAME | DIGIT*) ']' _
    | addFuncType
  )*

addFuncType
  = '(' _ ('*' !'=' _ | '^') _ (Name)? (_ '(' _ FunctionParamList ')' _ )? _ ')' _ '(' _ FunctionParamList ')' _

POINTER_QUALIFIER
  = 'const' !W _ | 'restrict' !W _

PrimaryType
  = StructDeclaration
  | 'void' !W _
  | SIGN? "char"   !W _
  | SIGN? "short"   !W _
  | SIGN? "int"   !W _
  | "float"    !W _
  | "double"  !W _
  | "long" !W _ "double" !W _
  | "long" !W (_ SIGN)? (_ "long" !W)? (_ "int" !W)? _
  | SIGN? "long" !W (_ "long" !W)? (_ "int" !W)? _
  | "signed" !W _
  | "unsigned" !W _
  | "_Bool" !W _
  | "_Complex" !W _
  | NAME_T _
  | NAME _

StructDeclaration
  = "struct" !W _ (Name)? addStructMember? 
  | "union" !W _ (Name)? addStructMember? 
  | "enum" !W  _ (Name)? ('{' _ EnumeratorList ',' _? '}' _)?

SIGN
  = ("signed" !W | "unsigned" !W | "__signed" !W ) _

NAME_T
  = !DIGIT (!('_t' !W)  W )+ '_t' !W
  
addStructMember
  = '{' _ (Directive | StructMemberDeclaration | _ )* _ '}' _

StructMemberDeclaration
  = AnnotationList Type StructMemberName  (',' _ StructMemberName )* (';' _ | EOL)  _ 
  | Type (';' _ | EOL)  _ 

StructMemberName
  = VarName ( ':' ![>] _ ConstantExpression )*
  | ':' ![>] _ ConstantExpression

EnumeratorList
  = Enumerator (',' _ Enumerator)* ',' _?

Enumerator
  = Name ( '=' !'=' _ ConstantExpression )?


Block
  = '{' _ (Directive |  Statement | Declaration | _ )* '}' _

Statement
  = Block
  | "if" !W _  '(' _ Expression ')' _ Statement ("else" _ Statement)?
  | "switch" !W _ '(' _ Expression ')' _ Statement
  | "while" !W _ '(' _ Expression ')' _ Statement
  | "do" _ Statement "while" _ '(' _ Expression ')' _ (';' _ | EOL)
  | "for" _ '(' _ (Expression)? (';' _ | EOL)  (Expression)? (';' _ | EOL)  (Expression)? ')' _ Statement
  | "for" _ '(' _ Declaration (Expression)? (';' _ | EOL)  (Expression)? (';' _ | EOL)  Statement 
  | "goto" _ Name (';' _ | EOL) 
  | "continue" _ (';' _ | EOL)  
  | "break" _ (';' _ | EOL) 
  | "return" _ (Expression)?  (';' _ | EOL)
  | "case" !W _ ConstantExpression ':' ![>] _ (!"case" !"default" Statement)*
  | "default" _ ':' ![>] _ (!"case" Statement)*
  | Name ':' ![>] _
  | Expression (';' _ | EOL)
  | (';' _ | EOL) 

Expression
  = AssignmentExpression (',' _ AssignmentExpression )*

AssignmentExpression
  = UnaryExpression addAssignmentOperator AssignmentExpression
  | ConditionalExpression

addAssignmentOperator
  = '=' !'=' _ 
  | "*="  _  
  | "/="  _  
  | "%="  _  
  | "+="  _  
  | "-="  _ 
  | "<<="  _ 
  | ">>=" _ 
  | "&="  _ 
  | "^="   _ 
  | "|="   _ 

ConstantExpression
  = ConditionalExpression
  
ConditionalExpression
  = LogicalORExpression ( '?' _  Expression ':' ![>] _ LogicalORExpression )*

LogicalORExpression
  = LogicalANDExpression ( "||" _ LogicalANDExpression )*

LogicalANDExpression
  = InclusiveORExpression ( "&&" _ InclusiveORExpression )*

InclusiveORExpression
  = ExclusiveORExpression ( '|' ![=] _ ExclusiveORExpression )*

ExclusiveORExpression
  = ANDExpression ( '^' ![=] _ ANDExpression )*

ANDExpression
  = EqualityExpression ( '&' !'&' _ EqualityExpression )*

EqualityExpression
  = RelationalExpression ( ( '==' _  | '!=' _ ) RelationalExpression )*
  
RelationalExpression
  = ShiftExpression ( ( '<=' _ | '>=' _ | '<' ![=] _ | '>' ![=] _  ) ShiftExpression )*
  
ShiftExpression
  = AdditiveExpression ( ( '<<' !'=' _ | '>>' !'=' _ ) AdditiveExpression )*
  
AdditiveExpression
  = MultiplicativeExpression ( ( '+' ![+=]  | '-' !('-' | [=>]) _  ) MultiplicativeExpression )*
  
MultiplicativeExpression
  = CastExpression ( ( '*' !'=' _ | '/' !'=' _ | '%' ![=>] _ ) CastExpression )*

UnaryExpression
  = PostfixExpression
  | '++' _    UnaryExpression 
  | '--' _    UnaryExpression 
  | '&' !'&' _    CastExpression 
  | '*' !'=' _   CastExpression 
  | '+' ![+=]    CastExpression 
  | '-' !('-' | [=>]) _  CastExpression
  | '~' _  CastExpression
  | '!' !'=' _   CastExpression 
  | 'sizeof' !W _  ( UnaryExpression | '(' _ Type ')' _ )

CastExpression
  = '(' _ Type ')' _ CastExpression
  | UnaryExpression

PostfixExpression
  = ( PrimaryExpression | { '(' _ Type ')' _ '{' _ ( (addInitializerList)* ',' _? ) '}' _ } ) 
  ((addFunctionCall | addPointerField | addIndex | addField | addInc | addDec) )*

addFunctionCall
  = '(' _ addArgumentExpressionList? ')' _ 

addArgumentExpressionList
  = (AssignmentExpression (',' _ AssignmentExpression)*)

addIndex
  = '[' _ Expression ']' _ 

addField
  = '.' _ Name 

addPointerField
  = '->' _ Name 

addInc
  = '++' _ 

addDec
  = '--' _ 

PrimaryExpression
  = Constant
  | CString
  | '(' _ Expression ')' _
  | Name


Constant
  = CFloat
  | CInteger
  | CChar

CFloat
  = ( DECIMAL_FLOAT | HEX_FLOAT ) FLOAT_SUFFIX? _

DECIMAL_FLOAT
  = FRACTION EXPONENT?
  | DIGIT+ EXPONENT

FRACTION
  = DIGIT* '.' DIGIT+
  | DIGIT+ '.'

EXPONENT
  = [eE] [+\-]? DIGIT+

HEX_FLOAT
  = HEX_PREFIX HEX_FRACTION BINARY_EXPONENT?
  | HEX_PREFIX HEX+ BINARY_EXPONENT

HEX_PREFIX
  = '0' [xX]

HEX_FRACTION
  = HEX* '.' HEX+
  | HEX+ '.'

BINARY_EXPONENT
  = [pP] [+\-]? DIGIT+

FLOAT_SUFFIX
  = [flFL]

CInteger
  = ( DECIMAL | HEXICAL | OCTAL ) INT_SUFFIX? _

DECIMAL
  = [1-9] DIGIT*

HEXICAL
  = HEX_PREFIX HEX+

OCTAL
  = '0' [0-7]*

INT_SUFFIX
  = [uU] LONG_SUFFIX?
  | LONG_SUFFIX [uU]?

LONG_SUFFIX
  = 'll'
  | 'LL'
  | [lL]

CString
  =  'L'? ('"' STRING_CONTENT* '"' _)+

CChar
  = 'L'? "'" CHAR_CONTENT* "'" _

STRING_CONTENT
  = ESCAPE
  | (&'\\\n' .. | ![\"\n\\] .)

CHAR_CONTENT
  = ESCAPE
  | !['\n\\] .

ESCAPE
  = SIMPLE_ESCAPE
  | OCTAL_ESCAPE
  | HEX_ESCAPE
  | UCHAR

SIMPLE_ESCAPE
  = '\\' ['\"?\\abfnrtv]
  
OCTAL_ESCAPE
  = '\\' [0-7] [0-7]? [0-7]?
  
HEX_ESCAPE
  = '\\x' HEX+


%%

void yyerror(char *message)
{
  fprintf(stderr, "%s:%d: %s", fileName, lineNumber, message);
  if (yyctx->__text[0]) fprintf(stderr, " near token '%s'", yyctx->__text);
  if (yyctx->__pos < yyctx->__limit || !feof(input))
    {
      yyctx->__buf[yyctx->__limit]= '\0';
      fprintf(stderr, " before text \"");
      while (yyctx->__pos < yyctx->__limit)
	{
	  if ('\n' == yyctx->__buf[yyctx->__pos] || '\r' == yyctx->__buf[yyctx->__pos]) break;
	  fputc(yyctx->__buf[yyctx->__pos++], stderr);
	}
      if (yyctx->__pos == yyctx->__limit)
	{
	  int c;
	  while (EOF != (c= fgetc(input)) && '\n' != c && '\r' != c)
	    fputc(c, stderr);
	}
      fputc('\"', stderr);
    }
  fprintf(stderr, "\n");
  exit(1);
}

void makeHeader(char *text)
{
  Header *header= (Header *)malloc(sizeof(Header));
  header->text= strdup(text);
  header->next= headers;
  headers= header;
}

void makeTrailer(char *text)
{
  trailer= strdup(text);
}

static void usage(char *name)
{
  fprintf(stderr, "usage: %s [<option>...] [<file>...]\n", name);
  fprintf(stderr, "where <option> can be\n");
  fprintf(stderr, "  -h          print this help information\n");
  fprintf(stderr, "  -o <ofile>  write output to <ofile>\n");
  fprintf(stderr, "  -v          be verbose\n");
  fprintf(stderr, "  -V          print version number and exit\n");
  fprintf(stderr, "if no <file> is given, input is read from stdin\n");
  fprintf(stderr, "if no <ofile> is given, output is written to stdout\n");
  exit(1);
}

uint64_t timer() {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

int main(int argc, char **argv)
{
  input= stdin;
  lineNumber= 1;
  fileName= "<stdin>";
  
  for (int i = 0; i < 5; i++) {
    if (argc >= 2) {
      if (!(input = fopen(argv[1], "r"))) {
        fprintf(stderr, "File [%s] is not found!\n", argv[1]);
        return 1;
      }
    }
  
    uint64_t start, end;
    start = timer();
    if ((yyparse())) {
      //json_print(stdout, json);
    } else {
      printf("xml error!\n");
    }
    end = timer();
  
    printf("ElapsedTime: %llu msec\n", end - start);
  }

  return 0;
}
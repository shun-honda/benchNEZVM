# LE Grammar for LE Grammars
# 
# Copyright (c) 2007 by Ian Piumarta
# All rights reserved.
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the 'Software'),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, provided that the above copyright notice(s) and this
# permission notice appear in all copies of the Software.  Acknowledgement
# of the use of this Software in supporting documentation would be
# appreciated but is not required.
# 
# THE SOFTWARE IS PROVIDED 'AS IS'.  USE ENTIRELY AT YOUR OWN RISK.
# 
# Last edited: 2013-08-16 00:14:11 by piumarta on emilia

%{
# include "xml.h"
# include "tree.h"
# include "version.h"

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <string.h>
# include <libgen.h>
# include <assert.h>
# include <time.h>

  typedef struct Header Header;

  struct Header {
    char   *text;
    Header *next;
  };

  FILE *input= 0;

  int   verboseFlag= 0;

  static int	 lineNumber= 0;
  static char	*fileName= 0;
  static char	*trailer= 0;
  static Header	*headers= 0;

  void makeHeader(char *text);
  void makeTrailer(char *text);

  void yyerror(char *message);

# define YY_INPUT(buf, result, max)		\
  {						\
    int c= getc(input);				\
    if ('\n' == c || '\r' == c) ++lineNumber;	\
    result= (EOF == c) ? 0 : (*(buf)= c, 1);	\
  }

# define YY_LOCAL(T)	static T
# define YY_RULE(T)	static T
%}

File
  = p:PROLOG? S* d:DTD? S* e:Xml S* { XML *xml = new_XML(); xml_add_values(xml, p, d, e); xml_print_xml(stdout, xml, 0); }

PROLOG
  = '<?xml' (s:pro_str) '?>' {$$ = xml_new_prolog(s);}

pro_str
  = (!'?>' .)* {$$ = xml_new_prolog_text(yytext);}

DTD
  = '<!' (s:dtd_text) '>' {$$ = xml_new_dtd(s);}

dtd_text
  = (!'>' .)* {$$ = xml_new_dtd_text(yytext);}

Xml
  = '<' n:Name (S+ a:Attribute)* S* ( '/>' | '>' S* (c:Content)? '</' NAME '>' ) S* {$$ = xml_new_element(n, a, c);}

Content
  = (f:Value {f = xml_new_content(f);} | COMMENT) (l:Value {f = xml_value_add_content(f, l);} | COMMENT)* {$$ = f;}

Name
  = [A-Za-z:] ('-' | [.0-9:A-Z_a-z])* {$$ = xml_new_name(yytext);}

NAME
  = [A-Za-z:] ('-' | [.0-9:A-Z_a-z])* 

Attribute
  = n:Name S* '=' S* s:String {$$ = xml_new_attr(n, s);}

String
  = '"' s:str '"' {$$ = s;}

str = (!'"' .)* {$$ = xml_new_string(yytext);}

Value
  = x:Xml { $$ = xml_new_element_value(x); } 
  | c:CDataSec { $$ = c;}
  | t:Text {$$ = t;}

CDataSec
  = '<![CDATA[' c:CDATA ']]>' S* {$$ = c;}

CDATA
  = (!']]>' !'<![CDATA[' .)*
    ('<![CDATA[' CDATA ']]>' CDATA)? {$$ = xml_new_cdata(yytext);}

COMMENT
  = '<!--' (!'-->' .)* '-->' S*

Text
  = (!'<' .)+ {$$ = xml_new_text(yytext);}

S
  = [ \n\t\r]

%%

void yyerror(char *message)
{
  fprintf(stderr, "%s:%d: %s", fileName, lineNumber, message);
  if (yyctx->__text[0]) fprintf(stderr, " near token '%s'", yyctx->__text);
  if (yyctx->__pos < yyctx->__limit || !feof(input))
    {
      yyctx->__buf[yyctx->__limit]= '\0';
      fprintf(stderr, " before text \"");
      while (yyctx->__pos < yyctx->__limit)
	{
	  if ('\n' == yyctx->__buf[yyctx->__pos] || '\r' == yyctx->__buf[yyctx->__pos]) break;
	  fputc(yyctx->__buf[yyctx->__pos++], stderr);
	}
      if (yyctx->__pos == yyctx->__limit)
	{
	  int c;
	  while (EOF != (c= fgetc(input)) && '\n' != c && '\r' != c)
	    fputc(c, stderr);
	}
      fputc('\"', stderr);
    }
  fprintf(stderr, "\n");
  exit(1);
}

void makeHeader(char *text)
{
  Header *header= (Header *)malloc(sizeof(Header));
  header->text= strdup(text);
  header->next= headers;
  headers= header;
}

void makeTrailer(char *text)
{
  trailer= strdup(text);
}

static void version(char *name)
{
  printf("%s version %d.%d.%d\n", name, PEG_MAJOR, PEG_MINOR, PEG_LEVEL);
}

static void usage(char *name)
{
  version(name);
  fprintf(stderr, "usage: %s [<option>...] [<file>...]\n", name);
  fprintf(stderr, "where <option> can be\n");
  fprintf(stderr, "  -h          print this help information\n");
  fprintf(stderr, "  -o <ofile>  write output to <ofile>\n");
  fprintf(stderr, "  -v          be verbose\n");
  fprintf(stderr, "  -V          print version number and exit\n");
  fprintf(stderr, "if no <file> is given, input is read from stdin\n");
  fprintf(stderr, "if no <ofile> is given, output is written to stdout\n");
  exit(1);
}

int main(int argc, char **argv)
{
  input= stdin;
  lineNumber= 1;
  fileName= "<stdin>";
  
  for (int i = 0; i < 5; i++) {
    if (argc >= 2) {
      if (!(input = fopen(argv[1], "r"))) {
        fprintf(stderr, "File [%s] is not found!\n", argv[1]);
        return 1;
      }
    }
  
    clock_t start = clock();
    if ((yyparse())) {
      //json_print(stdout, json);
    } else {
      printf("Json error!\n");
    }
    clock_t end = clock();
    
    printf("time: %f\n", (double)(end - start) / CLOCKS_PER_SEC);
  }

  return 0;
}